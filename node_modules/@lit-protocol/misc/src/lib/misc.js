"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIpAddress = exports.normalizeAndStringify = exports.sendRequest = exports.getEnv = exports.removeHexPrefix = exports.hexPrefixed = exports.defaultMintClaimCallback = exports.isSupportedLitNetwork = exports.genRandomPath = exports.decimalPlaces = exports.isBrowser = exports.isNode = exports.is = exports.numberToHex = exports.sortedObject = exports.checkIfAuthSigRequiresChainParam = exports.checkSchema = exports.checkType = exports.getVarType = exports.logError = exports.logErrorWithRequestId = exports.logWithRequestId = exports.log = exports.getLoggerbyId = exports.bootstrapLogManager = exports.throwRemovedFunctionError = exports.isNodeClientErrorV0 = exports.isNodeClientErrorV1 = exports.throwGenericError = exports.throwErrorV1 = exports.throwErrorV0 = exports.throwError = exports.findMostCommonResponse = exports.mostCommonString = exports.printError = void 0;
const constants_1 = require("@lit-protocol/constants");
const providers_1 = require("@ethersproject/providers");
const contracts_1 = require("@ethersproject/contracts");
const logger_1 = require("@lit-protocol/logger");
const ajv_1 = require("ajv");
const logBuffer = [];
const ajv = new ajv_1.default();
/**
 *
 * Print error message based on Error interface
 *
 * @param { Error } e
 * @returns { void }
 */
const printError = (e) => {
    console.log('Error Stack', e.stack);
    console.log('Error Name', e.name);
    console.log('Error Message', e.message);
};
exports.printError = printError;
/**
 *
 * Find the element that occurs the most in an array
 *
 * @param { Array<any> } arr
 * @returns { any } the element that appeared the most
 */
const mostCommonString = (arr) => {
    return arr
        .sort((a, b) => arr.filter((v) => v === a).length -
        arr.filter((v) => v === b).length)
        .pop();
};
exports.mostCommonString = mostCommonString;
const findMostCommonResponse = (responses) => {
    const result = {};
    // Aggregate all values for each key across all responses
    const keys = new Set(responses.flatMap(Object.keys));
    for (const key of keys) {
        const values = responses.map((response) => response[key]);
        // Filter out undefined values before processing
        const filteredValues = values.filter((value) => value !== undefined && value !== '');
        if (filteredValues.length === 0) {
            result[key] = undefined; // or set a default value if needed
        }
        else if (typeof filteredValues[0] === 'object' &&
            !Array.isArray(filteredValues[0])) {
            // Recursive case for objects
            result[key] = (0, exports.findMostCommonResponse)(filteredValues);
        }
        else {
            // Most common element from filtered values
            result[key] = (0, exports.mostCommonString)(filteredValues);
        }
    }
    return result;
};
exports.findMostCommonResponse = findMostCommonResponse;
const throwError = (e) => {
    if ((0, exports.isNodeClientErrorV1)(e)) {
        return (0, exports.throwErrorV1)(e);
    }
    else if ((0, exports.isNodeClientErrorV0)(e)) {
        return (0, exports.throwErrorV0)(e);
    }
    return (0, exports.throwGenericError)(e);
};
exports.throwError = throwError;
/**
 *
 * Standardized way to throw error in Lit Protocol projects
 *
 * @deprecated use throwErrorV1
 * @param { ILitError }
 * @property { string } message
 * @property { string } name
 * @property { string } errorCode
 */
const throwErrorV0 = ({ message, name, errorCode, error, }) => {
    const errConstructorFunc = function (message, name, errorCode) {
        this.message = message;
        this.name = name;
        // Map old error codes to new ones if possible.
        this.errorCode = oldErrorToNewErrorMap[errorCode] ?? errorCode;
    };
    throw new errConstructorFunc(message, (name = error?.name ?? name), (errorCode = error?.code ?? errorCode));
};
exports.throwErrorV0 = throwErrorV0;
// Map for old error codes to new ones
const oldErrorToNewErrorMap = {
    not_authorized: 'NodeNotAuthorized',
    storage_error: 'NodeStorageError',
};
/**
 *
 * Standardized way to throw error in Lit Protocol projects
 *
 */
const throwErrorV1 = ({ errorKind, details, status, message, errorCode, requestId, }) => {
    const errConstructorFunc = function (errorKind, status, details, message, errorCode, requestId) {
        this.message = message;
        this.errorCode = errorCode;
        this.errorKind = errorKind;
        this.status = status;
        this.details = details;
        this.requestId = requestId;
    };
    throw new errConstructorFunc(errorKind, status, details, message, errorCode, requestId);
};
exports.throwErrorV1 = throwErrorV1;
const throwGenericError = (e) => {
    const errConstructorFunc = function (message, requestId) {
        this.message = message;
        this.errorKind = constants_1.LIT_ERROR.UNKNOWN_ERROR.name;
        this.errorCode = constants_1.LIT_ERROR.UNKNOWN_ERROR.code;
        this.requestId = requestId;
    };
    throw new errConstructorFunc(e.message ?? 'Generic Error', e.requestId ?? 'No request ID found');
};
exports.throwGenericError = throwGenericError;
const isNodeClientErrorV1 = (nodeError) => {
    return (nodeError.hasOwnProperty('errorCode') &&
        nodeError.hasOwnProperty('errorKind'));
};
exports.isNodeClientErrorV1 = isNodeClientErrorV1;
const isNodeClientErrorV0 = (nodeError) => {
    return nodeError.hasOwnProperty('errorCode');
};
exports.isNodeClientErrorV0 = isNodeClientErrorV0;
const throwRemovedFunctionError = (functionName) => {
    (0, exports.throwError)({
        message: `This function "${functionName}" has been removed. Please use the old SDK.`,
        errorKind: constants_1.LIT_ERROR.REMOVED_FUNCTION_ERROR.kind,
        errorCode: constants_1.LIT_ERROR.REMOVED_FUNCTION_ERROR.name,
    });
};
exports.throwRemovedFunctionError = throwRemovedFunctionError;
const bootstrapLogManager = (id, level = logger_1.LogLevel.DEBUG) => {
    if (!globalThis.logManager) {
        globalThis.logManager = logger_1.LogManager.Instance;
        globalThis.logManager.withConfig({
            condenseLogs: true,
        });
        globalThis.logManager.setLevel(level);
    }
    globalThis.logger = globalThis.logManager.get(id);
};
exports.bootstrapLogManager = bootstrapLogManager;
const getLoggerbyId = (id) => {
    return globalThis.logManager.get(id);
};
exports.getLoggerbyId = getLoggerbyId;
/**
 *
 * console.log but prepend [Lit-JS-SDK] before the message
 *
 * @param { any } args
 *
 * @returns { void }
 */
const log = (...args) => {
    if (!globalThis) {
        // there is no globalThis, just print the log
        console.log(...args);
        return;
    }
    // check if config is loaded yet
    if (!globalThis?.litConfig) {
        // config isn't loaded yet, push into buffer
        logBuffer.push(args);
        return;
    }
    // if there are there are logs in buffer, print them first and empty the buffer.
    while (logBuffer.length > 0) {
        const log = logBuffer.shift() ?? '';
        globalThis?.logger && globalThis?.logger.debug(...log);
    }
    globalThis?.logger && globalThis?.logger.debug(...args);
};
exports.log = log;
const logWithRequestId = (id, ...args) => {
    if (!globalThis) {
        // there is no globalThis, just print the log
        console.log(...args);
        return;
    }
    // check if config is loaded yet
    if (!globalThis?.litConfig) {
        // config isn't loaded yet, push into buffer
        logBuffer.push(args);
        return;
    }
    // if there are there are logs in buffer, print them first and empty the buffer.
    while (logBuffer.length > 0) {
        const log = logBuffer.shift() ?? '';
        globalThis?.logger &&
            globalThis.logManager.get(globalThis.logger.category, id).debug(...log);
    }
    globalThis?.logger &&
        globalThis.logManager.get(globalThis.logger.category, id).debug(...args);
};
exports.logWithRequestId = logWithRequestId;
const logErrorWithRequestId = (id, ...args) => {
    if (!globalThis) {
        // there is no globalThis, just print the log
        console.log(...args);
        return;
    }
    // check if config is loaded yet
    if (!globalThis?.litConfig) {
        // config isn't loaded yet, push into buffer
        logBuffer.push(args);
        return;
    }
    // if there are there are logs in buffer, print them first and empty the buffer.
    while (logBuffer.length > 0) {
        const log = logBuffer.shift() ?? '';
        globalThis?.logger &&
            globalThis.logManager.get(globalThis.logger.category, id).error(...log);
    }
    globalThis?.logger &&
        globalThis.logManager.get(globalThis.logger.category, id).error(...args);
};
exports.logErrorWithRequestId = logErrorWithRequestId;
const logError = (...args) => {
    if (!globalThis) {
        // there is no globalThis, just print the log
        console.log(...args);
        return;
    }
    // check if config is loaded yet
    if (!globalThis?.litConfig) {
        // config isn't loaded yet, push into buffer
        logBuffer.push(args);
        return;
    }
    // if there are there are logs in buffer, print them first and empty the buffer.
    while (logBuffer.length > 0) {
        const log = logBuffer.shift() ?? '';
        globalThis?.logger &&
            globalThis.logManager.get(globalThis.logger.category).error(...log);
    }
    globalThis?.logger &&
        globalThis.logManager.get(globalThis.logger.category).error(...args);
};
exports.logError = logError;
/**
 *
 * Get the type of a variable, could be an object instance type.
 * eg Uint8Array instance should return 'Uint8Array` as string
 * or simply a `string` or `int` type
 *
 * @param { any } value
 * @returns { string } type
 */
const getVarType = (value) => {
    return Object.prototype.toString.call(value).slice(8, -1);
};
exports.getVarType = getVarType;
/**
 *
 *  Check if the given value is the given type
 *  If not, throw `invalidParamType` error
 *
 * @property { any } value
 * @property { Array<String> } allowedTypes
 * @property { string } paramName
 * @property { string } functionName
 * @property { boolean } throwOnError
 *
 * @returns { Boolean } true/false
 *
 */
const checkType = ({ value, allowedTypes, paramName, functionName, throwOnError = true, }) => {
    // -- validate
    if (!allowedTypes.includes((0, exports.getVarType)(value))) {
        const message = `Expecting ${allowedTypes.join(' or ')} type for parameter named ${paramName} in Lit-JS-SDK function ${functionName}(), but received "${(0, exports.getVarType)(value)}" type instead. value: ${value instanceof Object ? JSON.stringify(value) : value}`;
        if (throwOnError) {
            (0, exports.throwError)({
                message,
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        }
        return false;
    }
    // -- else
    return true;
};
exports.checkType = checkType;
/**
 * Check if the given value complies with the given schema
 * If not, throw `invalidParamType` error
 *
 * @param { any } value
 * @param { JSONSchemaType<any> } schema
 * @param { string } paramName
 * @param { string } functionName
 * @param { boolean } throwOnError
 *
 * @returns { Boolean } true/false
 */
const checkSchema = (value, schema, paramName, functionName, throwOnError = true) => {
    let validate = schema.$id ? ajv.getSchema(schema.$id) : undefined;
    if (!validate) {
        validate = ajv.compile(schema);
    }
    const validates = validate(value);
    const message = `FAILED schema validation for parameter named ${paramName} in Lit-JS-SDK function ${functionName}(). Value: ${value instanceof Object ? JSON.stringify(value) : value}. Errors: ${JSON.stringify(validate.errors)}`;
    if (!validates) {
        if (throwOnError) {
            (0, exports.throwError)({
                message,
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        }
        return false;
    }
    return true;
};
exports.checkSchema = checkSchema;
/**
 *
 * @param { AuthSig } authSig
 * @param { string } chain
 * @param { string } functionName
 *
 * @returns { boolean }
 */
const checkIfAuthSigRequiresChainParam = (authSig, chain, functionName) => {
    (0, exports.log)('checkIfAuthSigRequiresChainParam');
    for (const key of constants_1.LIT_AUTH_SIG_CHAIN_KEYS) {
        if (key in authSig) {
            return true;
        }
    }
    // if we're here, then we need the chain param
    if (!(0, exports.checkType)({
        value: chain,
        allowedTypes: ['String'],
        paramName: 'chain',
        functionName,
    })) {
        return false;
    }
    return true;
};
exports.checkIfAuthSigRequiresChainParam = checkIfAuthSigRequiresChainParam;
/**
 * TODO: Fix "any"
 * Sort object
 *
 * @param { any } obj
 * @returns { any }
 */
const sortedObject = (obj) => {
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map(exports.sortedObject);
    }
    const sortedKeys = Object.keys(obj).sort();
    const result = {};
    // NOTE: Use forEach instead of reduce for performance with large objects eg Wasm code
    sortedKeys.forEach((key) => {
        result[key] = (0, exports.sortedObject)(obj[key]);
    });
    return result;
};
exports.sortedObject = sortedObject;
/**
 *
 * Convert number to hex
 * @param { number } v
 * @return { string } hex value prexied with 0x
 */
const numberToHex = (v) => {
    return '0x' + v.toString(16);
};
exports.numberToHex = numberToHex;
/**
 *
 *  Check if the given value is the given type
 *  If not, throw `invalidParamType` error
 *
 * @param { any } value
 * @param { string } type
 * @param { string } paramName
 * @param { string } functionName
 * @returns { Boolean } true/false
 */
const is = (value, type, paramName, functionName, throwOnError = true) => {
    if ((0, exports.getVarType)(value) !== type) {
        let message = `Expecting "${type}" type for parameter named ${paramName} in Lit-JS-SDK function ${functionName}(), but received "${(0, exports.getVarType)(value)}" type instead. value: ${value instanceof Object ? JSON.stringify(value) : value}`;
        if (throwOnError) {
            (0, exports.throwError)({
                message,
                errorKind: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.kind,
                errorCode: constants_1.LIT_ERROR.INVALID_PARAM_TYPE.name,
            });
        }
        return false;
    }
    return true;
};
exports.is = is;
const isNode = () => {
    var isNode = false;
    // @ts-ignore
    if (typeof process === 'object') {
        // @ts-ignore
        if (typeof process.versions === 'object') {
            // @ts-ignore
            if (typeof process.versions.node !== 'undefined') {
                isNode = true;
            }
        }
    }
    return isNode;
};
exports.isNode = isNode;
const isBrowser = () => {
    return (0, exports.isNode)() === false;
};
exports.isBrowser = isBrowser;
/**
 *
 * Get the number of decimal places in a token
 *
 * @property { string } contractAddress The token contract address
 * @property { string } chain The chain on which the token is deployed
 *
 * @returns { number } The number of decimal places in the token
 */
const decimalPlaces = async ({ contractAddress, chain, }) => {
    const rpcUrl = constants_1.LIT_CHAINS[chain].rpcUrls[0];
    const web3 = new providers_1.JsonRpcProvider({
        url: rpcUrl,
        skipFetchSetup: true,
    });
    const contract = new contracts_1.Contract(contractAddress, constants_1.ABI_ERC20.abi, web3);
    return await contract['decimals']();
};
exports.decimalPlaces = decimalPlaces;
/**
 *
 * Generate a random path (for testing)
 *
 * @returns { string } The random path
 */
const genRandomPath = () => {
    return ('/' +
        Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15));
};
exports.genRandomPath = genRandomPath;
/**
 * Checks if the given LitNetwork value is supported.
 * @param litNetwork - The LitNetwork value to check.
 * @throws {Error} - Throws an error if the LitNetwork value is not supported.
 */
function isSupportedLitNetwork(litNetwork) {
    const supportedNetworks = Object.values(constants_1.LIT_NETWORK);
    if (!supportedNetworks.includes(litNetwork)) {
        throw new Error(`Unsupported LitNetwork! (${supportedNetworks.join('|')}) are supported.`);
    }
}
exports.isSupportedLitNetwork = isSupportedLitNetwork;
const defaultMintClaimCallback = async (params, network = 'cayenne') => {
    isSupportedLitNetwork(network);
    try {
        const AUTH_CLAIM_PATH = '/auth/claim';
        const relayUrl = params.relayUrl || constants_1.RELAYER_URL_BY_NETWORK[network];
        if (!relayUrl) {
            throw new Error('No relayUrl provided and no default relayUrl found for network');
        }
        const relayUrlWithPath = relayUrl + AUTH_CLAIM_PATH;
        const response = await fetch(relayUrlWithPath, {
            method: 'POST',
            body: JSON.stringify(params),
            headers: {
                'api-key': params.relayApiKey
                    ? params.relayApiKey
                    : '67e55044-10b1-426f-9247-bb680e5fe0c8_relayer',
                'Content-Type': 'application/json',
            },
        });
        if (response.status < 200 || response.status >= 400) {
            let errResp = (await response.json()) ?? '';
            let errStmt = `An error occured requesting "/auth/claim" endpoint ${JSON.stringify(errResp)}`;
            console.warn(errStmt);
            throw new Error(errStmt);
        }
        let body = await response.json();
        return body.requestId;
    }
    catch (e) {
        console.error(e.message);
        throw e;
    }
};
exports.defaultMintClaimCallback = defaultMintClaimCallback;
/**
 * Adds a '0x' prefix to a string if it doesn't already have one.
 * @param str - The input string.
 * @returns The input string with a '0x' prefix.
 */
const hexPrefixed = (str) => {
    if (str.startsWith('0x')) {
        return str;
    }
    return ('0x' + str);
};
exports.hexPrefixed = hexPrefixed;
/**
 * Removes the '0x' prefix from a hexadecimal string if it exists.
 *
 * @param str - The input string.
 * @returns The input string with the '0x' prefix removed, if present.
 */
const removeHexPrefix = (str) => {
    if (str.startsWith('0x')) {
        return str.slice(2);
    }
    return str;
};
exports.removeHexPrefix = removeHexPrefix;
/**
 * getEnv - Determine the debug status based on environment variables or URL query parameters.
 *
 * @function
 * @export
 * @param {Object} [options={}] - Configuration options for determining debug status.
 * @param {string} [options.nodeEnvVar='DEBUG'] - The Node.js environment variable to check.
 * @param {string} [options.urlQueryParam='dev'] - The URL query parameter to check in a browser environment.
 * @param {string} [options.urlQueryValue='debug=true'] - The expected value of the URL query parameter to enable debugging.
 * @param {boolean} [options.defaultValue=false] - The default boolean value to return if no debug conditions are met.
 * @returns {boolean} - True if debug conditions are met, otherwise returns the provided defaultValue.
 *
 * @example
 * // Usage in Node.js environment
 * process.env.DEBUG = 'true';
 * console.log(getEnv()); // Outputs: true
 *
 * @example
 * // Usage in Browser environment with URL: http://example.com?dev=debug=true
 * console.log(getEnv()); // Outputs: true
 */
function getEnv({ nodeEnvVar = 'DEBUG', urlQueryParam = 'dev', urlQueryValue = 'debug=true', defaultValue = false, } = {}) {
    // Node.js environment
    if ((0, exports.isNode)()) {
        return process.env[nodeEnvVar] === 'true';
    }
    // Browser environment
    else if ((0, exports.isBrowser)()) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(urlQueryParam) === urlQueryValue;
    }
    // Default
    return defaultValue;
}
exports.getEnv = getEnv;
function sendRequest(url, req, requestId) {
    return fetch(url, req)
        .then(async (response) => {
        const isJson = response.headers
            .get('content-type')
            ?.includes('application/json');
        const data = isJson ? await response.json() : null;
        if (!response.ok) {
            // get error message from body or default to response status
            const error = data || response.status;
            return Promise.reject(error);
        }
        return data;
    })
        .catch((error) => {
        (0, exports.logErrorWithRequestId)(requestId, `Something went wrong, internal id for request: lit_${requestId}. Please provide this identifier with any support requests. ${error?.message || error?.details
            ? `Error is ${error.message} - ${error.details}`
            : ''}`);
        return Promise.reject(error);
    });
}
exports.sendRequest = sendRequest;
/**
 * Attempts to normalize a string by unescaping it until it can be parsed as a JSON object,
 * then stringifies it exactly once. If the input is a regular string that does not represent
 * a JSON object or array, the function will return it as is without modification.
 * This function is designed to handle cases where strings might be excessively escaped due
 * to multiple layers of encoding, ensuring that JSON data is stored in a consistent and
 * predictable format, and regular strings are left unchanged.
 *
 * @param input The potentially excessively escaped string.
 * @return A string that is either the JSON.stringify version of the original JSON object
 *         or the original string if it does not represent a JSON object or array.
 */
function normalizeAndStringify(input) {
    try {
        // Directly return the string if it's not in a JSON format
        if (!input.startsWith('{') && !input.startsWith('[')) {
            return input;
        }
        // Attempt to parse the input as JSON
        const parsed = JSON.parse(input);
        // If parsing succeeds, return the stringified version of the parsed JSON
        return JSON.stringify(parsed);
    }
    catch (error) {
        // If parsing fails, it might be due to extra escaping
        const unescaped = input.replace(/\\(.)/g, '$1');
        // If unescaping doesn't change the string, return it as is
        if (input === unescaped) {
            return input;
        }
        // Otherwise, recursively call the function with the unescaped string
        return normalizeAndStringify(unescaped);
    }
}
exports.normalizeAndStringify = normalizeAndStringify;
/**
 * Retrieves the IP address associated with a given domain.
 * @param domain - The domain for which to retrieve the IP address.
 * @returns A Promise that resolves to the IP address.
 * @throws If no IP address is found or if the domain name is invalid.
 */
async function getIpAddress(domain) {
    const apiURL = `https://dns.google/resolve?name=${domain}&type=A`;
    try {
        const response = await fetch(apiURL);
        const data = await response.json();
        if (data.Answer && data.Answer.length > 0) {
            return data.Answer[0].data;
        }
        else {
            throw new Error('No IP Address found or bad domain name');
        }
    }
    catch (error) {
        throw new Error(error);
    }
}
exports.getIpAddress = getIpAddress;
//# sourceMappingURL=misc.js.map