"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseLitResource = exports.LitActionResource = exports.LitRLIResource = exports.LitPKPResource = exports.LitAccessControlConditionResource = void 0;
const types_1 = require("@lit-protocol/types");
const access_control_conditions_1 = require("@lit-protocol/access-control-conditions");
const uint8arrays_1 = require("@lit-protocol/uint8arrays");
const utils_1 = require("./utils");
class LitResourceBase {
    constructor(resource) {
        this.resource = resource;
    }
    getResourceKey() {
        return `${this.resourcePrefix}://${this.resource}`;
    }
    toString() {
        return this.getResourceKey();
    }
}
class LitAccessControlConditionResource extends LitResourceBase {
    /**
     * Creates a new LitAccessControlConditionResource.
     * @param resource The identifier for the resource. This should be the
     * hashed key value of the access control condition.
     */
    constructor(resource) {
        super(resource);
        this.resourcePrefix = types_1.LitResourcePrefix.AccessControlCondition;
    }
    isValidLitAbility(litAbility) {
        return (litAbility === types_1.LitAbility.AccessControlConditionDecryption ||
            litAbility === types_1.LitAbility.AccessControlConditionSigning);
    }
    /**
     * Composes a resource string by hashing access control conditions and appending a data hash.
     *
     * @param {AccessControlConditions} accs - The access control conditions to hash.
     * @param {string} dataToEncryptHash - The hash of the data to encrypt.
     * @returns {Promise<string>} The composed resource string in the format 'hashedAccs/dataToEncryptHash'.
     */
    static async generateResourceString(accs, dataToEncryptHash) {
        if (!accs || !dataToEncryptHash) {
            throw new Error('Invalid input: Access control conditions and data hash are required.');
        }
        const hashedAccs = await (0, access_control_conditions_1.hashAccessControlConditions)(accs);
        const hashedAccsStr = (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashedAccs), 'base16');
        const resourceString = `${hashedAccsStr}/${dataToEncryptHash}`;
        return resourceString;
    }
}
exports.LitAccessControlConditionResource = LitAccessControlConditionResource;
class LitPKPResource extends LitResourceBase {
    /**
     * Creates a new LitPKPResource.
     * @param resource The identifier for the resource. This should be the
     * PKP token ID.
     */
    constructor(resource) {
        const fixedResource = (0, utils_1.formatPKPResource)(resource);
        super(fixedResource);
        this.resourcePrefix = types_1.LitResourcePrefix.PKP;
    }
    isValidLitAbility(litAbility) {
        return litAbility === types_1.LitAbility.PKPSigning;
    }
}
exports.LitPKPResource = LitPKPResource;
class LitRLIResource extends LitResourceBase {
    /**
     * Creates a new LitRLIResource.
     * @param resource The identifier for the resource. This should be the
     * RLI token ID.
     */
    constructor(resource) {
        super(resource);
        this.resourcePrefix = types_1.LitResourcePrefix.RLI;
    }
    isValidLitAbility(litAbility) {
        return litAbility === types_1.LitAbility.RateLimitIncreaseAuth;
    }
}
exports.LitRLIResource = LitRLIResource;
class LitActionResource extends LitResourceBase {
    /**
     * Creates a new LitActionResource.
     * @param resource The identifier for the resource. This should be the
     * Lit Action IPFS CID.
     */
    constructor(resource) {
        super(resource);
        this.resourcePrefix = types_1.LitResourcePrefix.LitAction;
    }
    isValidLitAbility(litAbility) {
        return litAbility === types_1.LitAbility.LitActionExecution;
    }
}
exports.LitActionResource = LitActionResource;
function parseLitResource(resourceKey) {
    if (resourceKey.startsWith(types_1.LitResourcePrefix.AccessControlCondition)) {
        return new LitAccessControlConditionResource(resourceKey.substring(`${types_1.LitResourcePrefix.AccessControlCondition}://`.length));
    }
    else if (resourceKey.startsWith(types_1.LitResourcePrefix.PKP)) {
        return new LitPKPResource(resourceKey.substring(`${types_1.LitResourcePrefix.PKP}://`.length));
    }
    else if (resourceKey.startsWith(types_1.LitResourcePrefix.RLI)) {
        return new LitRLIResource(resourceKey.substring(`${types_1.LitResourcePrefix.RLI}://`.length));
    }
    else if (resourceKey.startsWith(types_1.LitResourcePrefix.LitAction)) {
        return new LitActionResource(resourceKey.substring(`${types_1.LitResourcePrefix.LitAction}://`.length));
    }
    throw new Error(`Invalid resource prefix: ${resourceKey}`);
}
exports.parseLitResource = parseLitResource;
//# sourceMappingURL=resources.js.map